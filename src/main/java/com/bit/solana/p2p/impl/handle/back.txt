        log.info("流处理收到数据: {}", msg);
        byte[] data = new byte[msg.readableBytes()];
        msg.readBytes(data);
        P2PMessage deserialize = P2PMessage.deserialize(data);
        deserialize.setQuicChannel(quicChannel);
        //是请求还是响应
        if (deserialize.isRequest()) {
            log.info("收到请求: {}", deserialize);
            Map<ProtocolEnum, ProtocolHandler> handlerMap = protocolRegistry.getHandlerMap();
            ProtocolHandler protocolHandler = handlerMap.get(ProtocolEnum.fromCode(deserialize.getType()));
            if (protocolHandler != null){
                byte[] handle = protocolHandler.handle(deserialize);
                if (handle != null){
                    //用原来的流写回
                    //包装型 ByteBuf 无需释放的底层逻辑
                    //Unpooled.wrappedBuffer(handle) 创建的 UnpooledHeapByteBuf 有两个关键特性：
                    //零拷贝：缓冲区不持有新内存，只是对外部 handle 字节数组的 “视图”；
                    //引用计数无意义：其 release() 方法仅修改引用计数，但不会释放任何内存（因为内存是外部的 byte[]，由 JVM 垃圾回收管理）。
                    ByteBuf byteBuf = Unpooled.wrappedBuffer(handle);
                    ctx.writeAndFlush(byteBuf);
                }
            }else {
                log.info("未注册的协议：{}", deserialize.getType());
            }
        }else if (deserialize.isResponse()) {
            log.info("收到响应: {}", deserialize);
            CompletableFuture<byte[]> ifPresent = RESPONSE_FUTURECACHE.asMap().remove(bytesToHex(deserialize.getRequestId()));
            if (ifPresent != null) {
                ifPresent.complete(data);
            }
        }else {
            log.info("收到普通消息: {}", deserialize);
        }


       extends SimpleChannelInboundHandler<ByteBuf>

           @Autowired
           private ProtocolRegistry protocolRegistry;
           @Autowired
           private CommonConfig commonConfig;