protobuf二进制 实现跨平台
用protobuf做序列化
与客户端交互都是JSON


┌───────────────┐  并发接收层  ┌───────────────┐  缓冲调度层  ┌───────────────┐  处理执行层  ┌───────────────┐
│  客户端请求   ├─────────────→│  异步接收器    ├────────────→│  优先级队列     ├─────────────→│  交易处理器   │
└───────────────┘            └───────────────┘            └───────────────┘            └───────┬───────┘
                                                                                               │
┌───────────────┐  监控与容错    ┌───────────────┐  状态同步     ┌───────────────┐                 │
│  告警/自愈    ←─────────────  ┤  集群管理器    ←─────────────┤  交易状态表          ←────────────────┘
└───────────────┘              └───────────────┘              └───────────────┘


高并发接收层：采用无锁环形缓冲区（Disruptor）作为交易入口，支撑 10 万 TPS 的写入吞吐量，避免锁竞争瓶颈。
处理调度层：基于线程池 + 批处理机制，控制每秒 1 万笔的处理速度，避免资源过载。
超时控制层：通过定时任务 + 原子状态标记，严格控制单交易处理超时（500ms）。
高可用层：结合持久化（防止数据丢失）、集群容错（避免单点故障）和自动恢复机制。


核心约束条件
出块间隔：固定 500ms 生成一个区块（即每秒 2 个区块）。
TPS 目标：目标支持 1 万 TPS（每秒处理 10,000 笔交易），因此每个区块需至少包含 10,000 / 2 = 5,000笔交易（理论最小值）。
区块大小限制：Solana 协议限制单区块最大约 1.4MB（BlockBody的totalSize字段用于校验）。假设单交易平均大小为 256 字节（含签名、账户、指令），则最大可容纳 1.4MB / 256B ≈ 5,500笔交易（实际需根据交易结构动态计算）。
处理能力：交易池的TxPoolImpl使用ForkJoinPool并行处理交易，线程数为CPU核心数*4，需确保提取的交易数量不超过线程池的并行处理能力（避免堆积）。

目标是每秒处理一万笔交易

目标是：10 万并发交易提交  每秒 1 万笔交易（TPS）

交易分组、并发调度、资源优化

无冲突交易并行化：通过账户锁 ID 分组，确保访问不同账户的交易可并行执行；
最大化单机 CPU、内存资源，减少锁竞争和 GC 开销；
交易提交、验证、执行全链路异步化，避免阻塞。


具体实现方案
交易分组与冲突检测（基于账户锁 ID）
目标：快速识别无冲突交易，为并行执行奠定基础。


JVM 配置：-Xms16G -Xmx16G -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:ParallelGCThreads=8

-Xms16G -Xmx16G -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:ParallelGCThreads=8 --add-modules jdk.incubator.vector

至少 8 核 CPU，16GB 内存，SSD 存储

部署建议
JVM 配置：-Xms16G -Xmx16G -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:ParallelGCThreads=8
服务器配置：至少 8 核 CPU，16GB 内存，SSD 存储
水平扩展：通过多个交易池实例 + 负载均衡实现更高并发
监控告警：对队列长度、处理延迟、失败率设置阈值告警


http://localhost:18333/monitor/system

保存区块是保存了 区块Hash 和 数据索引

protobuf做序列化


F:\softwareSpace\Protoc\protoc-31.1-win64\bin




验证数据库注入 可用性
分层数据传输
p2p网络 实现信令服务IP交换 中继传输



QUIC协议必须按照平台打包 windows


X公网: 服务端 10.107.106.105:8333 客户端 10.107.106.105:18333
A内网: 服务端 192.168.1.1:8333 客户端 192.168.1.1:8333  公网映射后 服务端 219.134.171.73:4649  客户端 219.134.171.73:1258
B内网: 服务端 192.168.1.2:8333 客户端 192.168.1.2:8333  公网映射后 服务端 219.134.468.73:9551  客户端 219.134.468.73:5394
A已经和X连接且正常通信 B已经和X连接且正常通信
现在A通过X知道B的信息  A也知道B是一个内网 A的客户端主动发起对B的服务端的连接持续每500ms一次 同时给协调者X发送信号 X将信号转发给B B也同时对A的服务器发起连接 此时能连接成功吗


如果A连续三次打洞失败 A就标记B为不可达 需要中继  同时给X发信号 让B也标记A需要中继  当A发送数据给B时 发送给X 并记录目标节点 X收到后转发这条消息给B  B收到并处理 如果协议需要回复 B就给X也发送一条中继消息 X转发给A即可

